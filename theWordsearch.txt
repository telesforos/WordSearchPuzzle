( * Ra ge atter wapel atter iveluche stats

| fozle:: sotfsets lus2le 2 Dinectww

‘Design’ Al i ped oe Morel pd fee cll

  
 
 

eh,” O ol eek 1 focal a rs SE at
MN nokrepe | woes uni,
ee gine i apt /

| wuorcl uneluy » <alle sa | t-g

 

Bol "jadi wigs aby fo i hia
5a nlualsch inv eb function:
pocket gbancdenns, bl
!  poeudonody, uw vacccly akok pow moeed,
te. ts ail a ofa al i nasthe.

peck > nua guiel

pied lot tig > Awhile ancl for Loops
ast qehalion poo Ad ale wnt. Atwell

upcumuts Yet

poopula t= Haw wh ee
vnc RE |

 

 

 

CS 49 - Data Structures Project 1 Requirements Greenbank
Project Name: WordSrch

Due Date: 11/13/97 (Thursday, 12th week of class)

 

Language: ANSI C++

Summary:

The object of this project is to produce a program that designs “Word Search” puzzles, as shown below, us-
ing a text file of words provided by the user. In accomplishing this goal, you will learn about the stack
data structure, C++ classes, templates and objects. You will also get to implement an example of a common
Artificial Intelligence (AI) technique called backtracking.

f
iy

ce

Pea 3

HPOHOKKHZWCOHNHPAWZxmtaAHNY
DPHPOOUMEXMUSOSBOSWAZ UE WH
OCUMFPERPSENDWNOUWMD~HOHAYUMOWO
ZUNNHNAUSMACONMRARGOM ETHER
WUOUOZHAYKXCAAMHADWOZOLY
OZUEKNONOMUNHACOKXGHAAWWH
ZQUDSWHHAKHSOAMKHNMOAUMALH
MOD NMP GH \S mW UMHONK SK
MAZAWWANAXKIGOWONZHHOHS
FORA MOUHAS ANS rpaczr ayn sy
PORAUHPDMOANHOl ZH HNZOzZHUSEK
OddwrKezZoKH Wl xHN>HCOpacIA
HOHHS OK Ent mOdnQAwWNAHH
WASWWHAHHSUOWWK Nr SHUN
NAHOASEPVUZIONUGHMKDNHEDPO
MECHA CHNU Oly OM ZHRA POM
WNAYPONYKMOUNMORZEdMCOmMHHOm
SHMAHDWPRHONKWUONOMHK HANA
MN EOKHUxMPHOHSKE MZ NM ROUND
CH DPONOQHOaRAKW ZUM EMD IORKCW
GUIMAKMNAAMWOHUHZZSAKHEC
PRPNNAGCKHH SPI Be DHCHNZORDE
UAEWUCRKHOMNND EDK DHCD
OAYPHEEPDBUNOUDOKRHKGINZOHMK
OVOMUNECHAPRAAKHNWAOKMaGOXMK
HNMQAUAKOASZHUKICWZKHORPHG
OPODOHWUPHNKHRUORMMARHO
MOR SUK UO COMMER HHNEZAAMNHSY
DEH PKHMAMOHDHARHPNUGWH
PURUWP DWE SUMUHDD MK ODHHUKK
OUUZDANNANdISnxmwtwWaAVOnU
HK DOS OWWOANHENA WW SAN CHL

Musical Instruments

1. BASSOON 8. ENGLISHHORN 15. PICCOLO

2. CELLO 9. FLUTE 16. SAXOPHONE

3. CHIMES 10. FRENCHHORN 17. TROMBONE

4. CLARINET 11. HARPSICHORD 18. TRUMPET

5. CORONET 12. OBOE 19. VIOLA -

6. CYMBALS 13. ORGAN 20. VIOLIN

7. DRUM 14. PIANO 21. XYLOPHONE

Overview:
A “Word Search” puzzle, as shown above, hides a list of words in a two dimensional grid _of letters.
Words are placed randomly within the grid in any of eight directions (up, down, left, right, diagonally
{ up, etc.). Words may also overlap, sharing characters. Any unused locations within the grid after all

‘ words have been placed, are filled with randomly generated characters intended as camouflage,

“eu, Page1 of 13

 

CS 49 - Data Structures Project 1 Requirements Greenbank

The general plan to build such a puzzle is fairly straightforward, : as follows: (
1. Ask the user for a list of words.
2. Initialize an empty two dimensional grid of type char.

3. For each.word in the word list
— a. Pick a random direction for a first try. ;
b. Pick a random column and row in the grid as a starting location. } : her ove, v4 chars
c. Attempt to place the word in the chosen location and direction. . €
d. If placement of the word fails,
i. Try another location and/or direction until successful or,
it. Until all positions and directions have been exhausted.
4. Display the puzzle.
5. Display the word list in alphabetical order.

It should be apparent even from this description that a data structure is needed to store the list of words.
A sequential, ordered, linear list would be an excellent choice for just such a list. But since this data struc-
ture has not yet been covered in class, we will use a simpler structure that has been discussed and is quite
sufficient for our needs, the Vector class. The individual words will be stored in instances of the String
class. Hence we will use a Vector of Stings, or Vector<String>.

A data structure must also be defined for the puzzle grid. We will create our own class, Puzzle, for this.
The header file for this class, including the class declaration, is supplied. The student must implement
the operations.

Random numbers need to be generated so that random directions and positions within the puzzle grid can

be determined during word insertion. We could simply use the random number generator that is part of

every C and C++ library and convert its output to the proper ranges. Instead, we will use a more sophisticated and powerful random number generator that will be provided called the Rndm class.

A main program file must always exist. The desire here is to keep the main program loop as short and
high level as possible, with most of the work performed by the various class objects. Since the user inter-
face specified is rudimentary, the main program loop will perform this task, calling member functions
from the Puzzle object to build and display the puzzle, and member functions from a descendant of the Vector class called WordList to record, sort, and display the columns of words.

Therefore, the student's primary responsibility is to write the routines which | manage the puzzle grid.
These are the routines which actually design the puzzle, the remaining objects provide support. For this
reason, a more in-depth look at step 3 of the previous outline is in order.

Placing Words in the Puzzle Grid:

Once the word list has been obtained, and the puzzle grid initialized, the words need to be placed within
the grid. To make the puzzle challenging, the words should be placed as randomly as possible in terms of
both location and direction, and the more overlap of characters the better (a denser puzzle). Choosing an

initial random starting location and direction is simple with the use of the random number generator. The
problem is how to respond to the frequent case of not being able to place the word in the chosen location or
direction. Should a new location be attempted first, or a new direction?

If a new direction is always attempted first, there is a tendency for all the words to line up in a single direction, since this is the easiest way to squeeze the words into the limited space of the puzzle grid. So in-
stead, when a word insertion fails, a new location is sought first. Only after the word has been tried at

every possible location within the grid, is a new direction attempted; and then all locations must be re-tried for the new direction. This assures priority of randomness of direction, over that of position.

Page2 of 13

 

CS 49 - Data Structures Project 1 Requirements Greenbank
-

The method outlined above can successfully build a good puzzle from ail but the longest word lists. But
what happens when some of the words in the list have been placed in the puzzle, yet the remaining

- words cannot be placed anywhere in the remaining space. Enough free space might still be left in the puz-
zle to hold all the remaining words, but the space is too fragmented after placement of preceding words.
One solution could be for the program to simply admit defeat at this point and quit, but we wont give up so

easy. This is where the technique of “backtracking” and the stack come into use.

   
 
  

Backtracking and the Stack:

Assume the condition exists where several words have already been successfully placed in the puzzle
grid, but the next word does not fit, even after exhaustively trying every possible combination of location
and direction. If one or more of the earlier inserted words were to be taken back out, and replaced in a dif-
ferent position or orientation, the puzzle might still be completed. This technique of undoing earlier
failed attempts is known as backtracking.

_ The general idea in backtracking is to pursue a course of action as far as possible until either successful, or
a dead end is reached. If a dead end is reached, previous steps are undone, in reverse order, until a new,
previously untried, forward path can be followed. This process of going forward until blocked, then re-
tracing your steps to try another as yet untried option, is the artificial intelligence technique called back-
tracking.

In this project, when the Puzzle class is unable to insert a word from the word list into the puzzle grid, it
backtracks. This is done by removing the last successfully placed word, attempting to place that same
word in a new position or direction, and then going forward again. If the last placed word cannot be re-
placed in a new position or direction, backtracking goes further, removing the second-to-last successfully
placed word and the process is repeated. It is possible for this to continue until all previously placed
words have been removed and replaced in every possible combination.

In order to retrace earlier word placement, a record must be kept of every word placed, its position, direc-
fion, and a count of how many previous px many previous positions and directions have already been tried (it serves no pur-
pose duplicating positions already tested and rejected). We will create a class called Attempt just for
recording this information about word insertion attempts. It is necessary to be able to access these Attempt

records in the reverse order that they were produced. Needing to store and access objects in reverse order is
exactly what a stack does best. - ~

 

 

So, each time a word is successfully placed in the puzzle, an Attempt object containing the word’s index
into the Vector of words, position, direction, and count of earlier positions and directions, is recorded and
pushed onto a stack. Whenever a word insertion into the puzzle grid fails, the last Attempt object from
the stack is popped, and the information stored in the Attempt object is used to remove the last successful-
ly placed word from the puzzle. The program then continues forward again, trying to place the popped
word in a new location or direction. Total failure occurs only if a word insertion fails, and the stack is
empty. The permutations possible in such an exhaustive search are staggering. A completely exhaustive
search of this kind for even a moderately sized puzzle could take more than your lifetime. Fortunately for
most practical puzzles a solution is usually found quite fast.

One last complication arises when removing previously inserted words. Because words may overlap posi-
tions sharing a letter in the grid, the removal algorithm cannot extract a word simply by marking all
spaces as empty that the word occupied. Doing so would leave blanks in other words still remaining in
the grid. To prevent this, each grid location must also keep a count of how many words share that space.
This way, when.a word is removed from the grid, a letter location is set “Empty” only if that position be-
longs to a single word. This count must be decremented for each letter position whenever a word is re-
moved, and incremented whenever a word is inserted.

Page3 of 13

 

CS 49 - Data Structures Project 1 Reguirements Greenbank
Input Specifications:

The user is prompted for the name of a text (.txt) file containing the list of words to be hidden in the Word
Search puzzle. If the word file does not reside in the same directory as the WordSrch.exe program, then
the entire path name must be supplied.

The format of the word list text file is as follows:

Ist line Puzzle name - the entire first line of the file is used as the puzzle title.

2nd line Height & Width- the second line provides two integers, separated by a space, specifying
the puzzle height and width. Both integers must be greater than zero.

3rd... Word - each remaining line of the puzzle provides one word to be hidden in the
puzzle. Words can be any number of characters as long as they are not
longer than the largest dimension of the puzzle. Words cannot contain
embedded spaces.

After the file name has been entered, the puzzle is designed and displayed. The user is then prompted
whether to create another puzzle or quit.

Output Specifications:

Once the puzzle is successfully designed it must be displayed on the screen and saved to a file. Only the
puzzle letter grid is displayed on screen. Rows of the puzzle letter grid are single spaced; columns should
have one space between letters.

The entire puzzle including both the letter grid and column. word list is saved to a text file called Puz-
zles.txt. Following the puzzle grid the list of words is displayed in numbered columns, in alphabetical or-
der, single spaced. The exact number of columns to use is computed by determining the number of columns of
the largest word which fit evenly within the width set by the puzzle grid. (See the example on the first
page of this handout for reference.)

Puzzles.txt can then be viewed or printed from any word processor or text editor. The puzzle file should be
viewed and printed using a monospaced font. such as Courier.

If the program is unable to complete a puzzle from the given list of words, a simple error message is dis-
played on the screen.

Page4 of 13

~—s

 

CS 49 - Data Structures Project 1 Requirements Greenbank
{ Project:

As in every project of any but the most simplistic nature, this project consists of a collection of separate
files. The table below details the files required by this project. Standard C++ library files (such as ios-
tream) are not mentioned. Files checked as Given are provided complete and should be included. in the
project without modification. The student must implement only Puzzle.cpp and Attempt.cpp.

 

 

 

 

 

 

 

 

 

 

 

  

 

 

 

 

 

 

 

Given: Module Given Associated Header(s) | Description
a v/. WordSrch.cpp co oe Top level main program file
—_> AL... ‘Puzzle.cpp | /_ Puzzle.h. a Puzzle class - designs word search puzzles
> Spe Attempt.cpp..)v.Attempt-h | Attempt class - records one word insertion attempt _
2 Vv StackAr.cpp__| Vv AbsStack.h, StackAr.h | Class template for array implementation of stack _
A MM _Vector.cpp V Mector.h Class template for a bounded vector
AA... String.cpp _M_.String.h Provides dynamic allocation and comparison of strings
P7|-Now WordList.cpp... Vv. WordList.h uuu. Vector of Strings, provides sorting and printing
14) be 7 Holds all explicit template instantiations
4 CRndm.cpp.o jovi Radm.b _o... Random number generator .
7 |_+/___Exception.cpp ~/_:Exception.h Error function used in place of true exception handling

 

Copy the Word Srch directory (folder) and all its contents from the file server to your diskette. From

within Borland C++ create a new project file called Word Srch.ide and save it in the same directory as

the source files. Add each of the .cpp files to the project file. The project file will become aware of the in-
/ cluded .h files when the first build operation is performed.

 

cy

template.cpp [ .cpp]
attempt.cpp [.cpp]
, (4 wordlist cpp [.cpp]
qe By yector.cpp [.cpp) cor:

   
  

 

 
  
  
   
  
  

string.cpp [.cpp] coc
rndm.cpp [.cpp] code—
exception.cpp [.cpp] |
: stackar.cpp [.cpp] c
fy puzzle.cpp [.cpp] co
FY worderch.cpp [.cpp]

 

  
  

 

Example Borland C++ 5.0 Project Window for WordSrch Project

Page5 of 13

 

CS 49 - Data Structures Project 1 Requirements Greenbank

_—s

Important Algorithms:

Main Program File:

This file is provided in its entirety. The main program file includes a very simple user interface to prompt
for the word list, constructs a WordList (Vector) object to contain and display the list, constructs and di-
rects a Puzzle object to design and display the puzzle, and constructs an ofstream object to record the results
in a text file. Use this file exactly as provided, donot alter or modify.

Puzzle class:

This is the object which performs the main task of designing a word search puzzle from a given list of
words. The Puzzle class encapsulates the data required to define a word search puzzle together with the
operations allowed on that data. The interface for this class, Puzzle.h, is given and should be used with-
out modification. The student must implement the body of the class, Puzzle.cpp. The class declaration is
reproduced below.

class Puzzle
{

public:
Puzzle(const Vector<String> & TheWords, int TheHeight
int TheWidth = 32);
~Puzzle();

VY ——_—3 int Design();

_ ——— -» friend ostream & operator<< (ostream & Out, const Puzzle & Rhs);
ppv 7 P -

 

private: (
const Vector<String> & Words; // List of words to put in puzzle
Pyne J Y——-— Stack<Attempt> *AttemptStack; // Stack of previously inserted words
Ded nm enum {WALL = '#', EMPTY = ' '}; \ ( )
- gtruct LetterBox thon & wo?
. 4 ddinda. yotwW
char Letter; // A..%2; WALL; EMPTY
int Copies; // Number of words that share the Letter efor bactoacking
}F .
int Height; // Height of puzzle .
int Width; // Width of puzzle
pair to pate \__LetterBox ,#*Grid; // Two dimensional array [Height + 2][Width + 2]
struct Offsets // Direction offsets
{
int Vert; // -1..1
int Horz; // -1..1
hi

/ chat > bh cep 7 static const Offsets Directions[NUM DIRECTIONS]; // Eight directions
dn Static Rndm RandGen;
void Reset();
int InsertOneWord(const Attempt & OneWord);
void RemoveOneWord(const Attempt & OneWord);

void FillRemainder();

}i

Page6é of 13

 

CS 49 - Data Structures Project 1 Reguirements Greenbank

The Puzzle data members store: a Vector of String’s, each String containing one word to be inserted in the
puzzle; a Stack to record word insertion Attempt objects; the height and width of the puzzle grid; and a

dynamically allocated two-dimensional array of LetterBox’s, each LetterBox represents one letter posi-
tion in the puzzle grid, its letter value and count of times that letter is shared.

Puzzle::RandGen:

This static data member shared by every instance of the Puzzle class holds a Rndmrandomnumbergen-
erator object. It should be constructed with the default (zero parameter) constructor.

Puzzle::Directions|NUM_ DIRECTIONSI:

This static const data member is an array of direction Offsets and is shared by every instance of the Puz-
zle class. It must be initialized in the Puzzle.cpp file. Use the following table to set the contents of this
array. Each pair of offsets represents one direction a word can be placed in the puzzle grid. Adding the
horizontal and vertical offsets to the current column and row indexes moves the word in the desired direc-

 

 

 

 

 

tion.
2
3 1
Index O 1:2 3 4 5:6 7 ; °
Vert.) OO -Vard dO dd, 5 7
Horz., 1 1°: 0 --1:-1 > -1 0047 6
Table of Direction Offsets Direction Wheel

Puzzle::Puzzle(const_Vector<String> & TheWords, int TheHeight, int TheWidth) constructor:

The Puzzle constructor initializes a new empty puzzle object of the requested size and records the word list
to be used in generating the puzzle.

Save the height, width, and reference to the list of words

Dynamically allocate and store a new empty stack for attempt records

Dynamically allocate a two dimensional puzzle grid; Rows: 0..(Height+1), Columns: 0..(Width+1)
Call the Reset() function to initialize the contents of the puzzle grid.

’ The last page of these instructions includes a brief explanation of how to dynamically allocate two-di-
mensional arrays. ,

Notice that the actual size of the grid allocated is two rows and two columns larger than the puzzle size
requested by the user. This is to accommodate an outer border or wall of “#”s which completely encircles
the grid of letters. This outer wall saves a considerable amount of index range checking during the design
phase of the puzzle. See the description of the Reset() function for a diagram of an empty, initialized
puzzle grid and the outer wall.

Puzzle:~PuzzleQ destructor:
The Puzzle destructor must ensure that any data members dynamically allocated by this object are re-
leased to prevent memory leaks. Specifically both the attempt stack and the two-dimensional puzzle

grid must be released. Deleting the two dimensional puzzle grid is the inverse operation of the two step
allocation process.

Page7 of 13

 

CS 49 - Data Structures Project 1 Requirements Greenbank
void. Puzzle::Reset():

This private member function clears the puzzle grid to an initial empty state.

For every cell in the two dimensional Grid
Set the copy count to zero
If the cell is an outer wall
Set the letter to WALL
Else
Set the letter to EMPTY

A diagram of a newly reset grid for.a 8 x 16 puzzle is shown below.

 

 

 

 

 

 

 

 

 

 

|< $—____———_- Width = 16 ————_—_—_———_ >
o'1.2 3 4 5 6 7.8 9 10 11 12 13:14 15 16'17
ol#l# | #l#l ele lal el el el ele) el el el el) 4) e
A i|# #
Hy 2) # #
e 3] # #| Outer WALL
1
g 4|# #
h5|¥ #
t
- 61# | #
8 71# ~+|#
P—— Grid[7}[15]
y el# #
o|#| #1 #l#)#l#lF#l#l Fl Fl el el él al alae] #14

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

Grid[{[Height+2][Width+2 ]
Initialized Puzzle Grid

ostream & operator<< (ostream & Out, const Puzzle & Rhs):

This friend of the Puzzle class is used to print the formatted contents of the puzzle grid to the given os-
tream object. Note this routine should work identically whether printing to the screen or a text file.

For all positions within the two-dimensional grid except the outermost wall
Print the grid letter to Out followed by one space
At the end of each row print a single endl

void Puzzle::FillRemainder():

After all of the words in the word list have been inserted into the puzzle grid, the remaining unused grid
positions should be filled with randomly generated capital letters. This private member function per-
forms that service.

For all positions within the two-dimensional grid except the outermost wall

If the grid position is EMPTY
Fill the position with a capital letter (AZ) {use RandGen.UniformLong for this}

Pages of 13

_N,

 

CS 49 - Data Structures Project 1 Requirements Greenbank
int Puzzle::InsertOneWord(const Attempt & OneWord):

The task of this private member function is to attempt to insert just one word into the puzzle grid, at one
location, in one direction. If successful the grid is updated with the presence of the new word and this
function returns 1. Else the grid is unmodified and the function returns 0.

Since word insertion will on average fail many times before each success, this algorithm verifies com-
pletely that the word will fit before inserting. This saves a lot of time having to remove partially in-
serted words.

The information about which word to insert, where the first letter of the word should be inserted, and in
which direction the word should be inserted is all contained in the OneWord object.

// First see if the word will fit; don’t modify the. grid yet
Set a pair of row and colunin indexes to the first grid position given by OneWord
For each letter in the word identified by OneWord.ID
If the grid position at the current row and column is EMPTY or contains the same letier
Add the direction offsets to the current row and column indexes to check the next position
Else
The word wont fit, return 0
// The word will fit so put it there
Reset the row and column indexes back to the first grid position specified by OneWord
For each letter in the word identified by OneWord.]D
Store the current letter of the word at the current row and column position
Increment the copy count for the letter position to show this letter is in use and may be shared
Add the direction offsets to the current row and column indexes to move to the next position
Return 1

Notice that if the starting location for the word is within the outer wall of the grid, it is impossible for

t his algorithm to go out of bounds. Hence it is not necessary to verify that each grid row and column index
is in range before accessing the array. The insertion algorithm always stops if a tested grid position is
non-empty with a letter different than the letter from the word. So as long as none of the words contain
the same character used in the WALL, this algorithm is safe, and a lot of simple but time consuming range
checking can be avoided. This is a common trade-off between time and space. A little extra space in the
form of two extra rows and columns made for a quicker more streamlined algorithm.

void Puzzle::RemoveOneWord(const Attempt & OneWord):

A word which was previously placed successfully into the word grid must now be removed due to back-
tracking. This private member function must remove the word specified by OneWord, at the recorded
starting position and direction, and restore the grid to its condition prior to the insertion. This function
must take into account that some letters in the grid may be shared by more than one word.

Set a pair of row and column indexes to the first grid position recorded for OneWord
For each letter of the word identified by OneWord.ID
Decrement the copy count for the grid position to show one less word is sharing this letter
If the updated copy count is zero
Mark the position in the grid as EMPTY
Add the direction offsets to the current row and column indexes to move to the next position

Page9 of 13

 

CS 49 - Data Structures Project 1 Requirements Greenbank
int Puzzle::Design(Q):

This public member function is the heart of the puzzle object. This function attempts to place all words of
the word list into the puzzle grid, at random locations, and in random directions. This function returns 1
when successful. It would return 0 only if every possible permutation of word placement fails.

Construct a local attempt record for the first word in the list, give it the puzzle height and width
While the attempt record word index is within the bounds of the word list
If the Word can be inserted successfully into the puzzle grid
Push the attempt record onto the stack
Update the local attempt record to the next word in the list
else
Set a flag true if more positions or directions can still be attempted for the current word
while that flag is false and the stack is not empty
Retrieve and remove an attempt record from the top of the stack
Remove the word represented by that attempt record from the grid
Set the flag true if the popped attempt record has more posttions or directions to try
If the flag is false
Return 0
Fill the unused positions of the grid with randomly generated letters
Return 1

Attempt class:

The declaration of the Attempt class, as provided in Attempt.h, is reproduced below and must be used
- without modification. The student must implement the body (Attempt.cpp).

const NUM_DIRECTIONS = 8; // Possible direction indexes 0..(NUM_DIRECTIONS~1)
class Attempt

{
public:
Attempt() {}; // Default, does. no initialization, but required.
Attempt(int TheWordIndex, int TheHeight, int TheWidth);// Primary means
int ID() const {return WordIndex; }
int FirstVert() const {return VertStart;}
int FirstHorz() const {return HorzStart;}
int Direction() const {return DirectionIndex;}
void NextWord() {WordIndext++; PickFirstTry();}
int NextTry();_
private:
int. WordIndex; // Index of word represented by this object; >= 0
int DirectionIndex; // 0..(NUM_DIRECTIONS - 1); current index
int DirectionAttempt; // 1..NUM_DIRECTIONS; number of directions tried
int Height; // Height of puzzle
int Width; // Width of puzzle
int VertStart; // 1..Height
int HorzStart; // 1..Width
int NumPositions; // Width * Height
int PositionAttempt; // 1..NumPositions; number of positions tried
static Rndm RandGen; // A pseudo-random number generator shared by class
aaa Aa TTR RAE REE PSE I
void PickFirstTry();
‘eG

Page 10 of 13

 

CS 49 - Data Structures Project 1 Requirements Greenbank

This class is used to record one attempt to place a word within the two-dimensional puzzle grid. Each At-
tempt object keeps tracks of one word’s index into a list of words, the current position and direction for in-
serting that word in the puzzle grid, and a count of how many previous positions have already been tried
plus how many directions have been tried at the current location.

Attempt::RandGen:

This static data member, which holds a Rndm random number generator object, is shared by every in-
stance of the Attempt class . lt should be constructed with the default (zero parameter) constructor. The
Puzzle and Attempt classes each have their own Rndm members so that they do not have to continually
pass back and forth a reference to a single instance.

Attempt: Attempt(int TheWordIndex, int TheHeight, int TheWidth) constructor:

This is the primary constructor for the Attempt class. All data members of the Attempt object should be
initialized following this function.

Save the word index, height, and width
Compute and save the total number of possible letter positions from the height and width
Call PickFirstTry() to complete the initialization

void Attempt::PickFirstTry():

This private member function sets (or resets) the data members of the Attempt record in preparation for
the first word insertion attempt. A random starting position and direction is generated, and the attempt
counters are reset.

Generate a uniform random direction index in the range 0.(NUM_DIRECTIONS-1)
Generate a uniform random horizontal start index in the range 1..Width

Generate a uniform random vertical start index in the range 1..Height

Set both the direction and position attempt counts to 1

int Attempt:NextTry(Q:

This public member function attempts to find an untried position or direction for word insertion and returns
1 if successful. This function returns 0 if every position has already been tried using each direction.

If fewer positions have been tried than are possible
Increment the position count
Increment the ltorizontal start index (have the index wrap around to 1 if greater than width)
If the horizontal index wrapped around to the left most position
Increment the vertical start index (wrap around to 1 if greater than height this time)
Return 1
Else if fewer directions have been tried than are possible
Increment the direction count
Reset the positiou count to 1 .
Increment the direction index (wrap around to 0 if equal to NUM_DIRECTIONS)
Return 1
Return 0

Page11 of 13

 

CS 49 - Data Structures Project 1 Requirements Greenbank

Vector class:

This is the bounded Vector described in your textbook with one exception, the private class data members
have been made protected. This was so that the Vector could more readily serve as a base class for the
derived WordList class. This change does not affect the way the student uses the Vector class from with-
in the Puzzle and Attempt classes.

For this project, the Vector of words used by the Puzzle and Attempt classes is considered filled, with no
empty slots. To find the number of words in the Vector, use the Length() member function.

Rndm class:

This class provides an excellent 32-bit random number generator with a number of common and useful dis-
tribution routines, suitable for a wide assortment of programming problems. However for this project the
student need be concerned with only two of the member functions: the constructor, and the uniform integer
distribution function.

For this project, construct instances of the Rndm class using the default constructor (zero parameters). This
will set the seeds of the Rndm object from the system clock, giving a different sequence of pseudo-random
numbers each time it is constructed.

The only member function required for this project is the UniformLong() function. For example: using an in-
stance of the Rndm class called RandGen to generate.a uniformly distributed random horizontal start in-
dex from 1..Width you would do:

HorzStart = RandGen.UniformLong(1, Width);

Hand-in requirements:

Source Code:
A. — Hand in the completed source code for:
— > 1. Attempt.cpp
— > 2. ~ Puzzlecpp
=» The header file and class declarations for the above modules must be used exactly as provided.
=+ Do not hand in copies of the remaining files as they are to remain unmodified.
B. Follow the Format and Style Guidelines for CS #4 Data Structures as provided to you at the beginning of

the semester. Remember 3 points of your grade reflect your adherence to these guidelines.

TestOutput:

A.

In the directory with the source files for this project are three text files:
Transpri.txt Garden.ixt Studies.txt
Use your completed program to generate word search puzzles from each of these three text files.

The results will be written to a text file generated by your program called Puzzles.txt. Print each resulting
puzzle, together with its word list,.on a separate page.

Locate and circle at least three of the hidden words in each of your puzzles.

Hand in the puzzle pages with the three circled hidden words together with your source code.

Page12 of 13

 

Dynamically allocating a two-dimensional array in C++:

In C++ a one dimensional array of int's would be dynamically allocated as follows:
int *Array = new int [Count]; // Indexes 0..(Count-1)

and accessed by:
Array[Index] = 3;

What this actually defines is a const pointer called Array that points to a block of memory large enough
to store Count number of int’s contiguously in the Free Store (application heap) as diagramed below.

Array 0 1 2 3 4
int* > int int int int int

 

 

 

 

 

 

 

 

 

 

 

 

 

Declaring and allocating a dynamic two-dimensional array is a bit more complicated. A statically allo-
cated two-dimensional array of int’s would be defined as follows:

int Array[Rows][Columns];
where Rows and Columns would have to be constants known at compile time. And would be accessed by:

Array[2][3] = 3;

What this actually defines is not a pointer to a single block of memory big enough to hold Rows x Columns
of int’s (as in many languages), but instead a pointer to an array of Row number of pointers which each in
turn point to an array of Column number of int’s as diagramed below.

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

ar
Array
int** Array[0][2]
Letterb ex 0 1 2 3 4
0 apt * int int int int int
R 0 1 2 3 4
ol int* int int int int int
W
5 0 1 2 3 4
2 int* int int int int int
0 1 2 3 4
3 int*® -— int int int int int
Columns

But when the number of Rows and Columns is not known until run-time, then dynamic allocation must be
used as follows:

//. To declare a. two-dimensional array
int **Array; // an array of arrays of int’s

// To allocate the two-dimensional array

Array = new int * [Rows]; // an array of pointers to int’s
for (int i = 0; i < Rows; i++)
Array[ij] = new int [Columns]; // one array of int’s

// Accessed by:
Array [Rowindex]{Columnindex] = 3;

 

PUZZLE.CPP November 13, 1997 Pag

//Programmer: James Moore 2

//Course: CS14 TT (cde) oo = Chormat) =
//File name:puzzle.cpp 7

//Project Name: Wordsrch

typedef int Boolean;
const Boolean TRUE = 1;
const Boolean FALSE = 0;

const Puzzle::Offsets Puzzle: :Directions [NUM DIRECTIONS] =
//Directions 0 1 2 3 4 5 6 7 ek.

{{0,1}, {-1,1}, {-1,0}, {-1,-1}, {0, u {1,-1}, {2,0}, (1,1}}; a xe

Puzzle: :Puzzle(const Vector<String>& TheWords,int TheHeight,
int TheWidth) :Words (TheWords)

Height = TheHeight;
Width = TheWidth;

AttemptStack = new Stack<Attempt>;

Grid = new LetterBox * [Height + 2]; af

&—for (int 1 = 0;i < Height+2;i++)

1 «w-Grid[i]=new LetterBox [Width + 2];

Resdt (); (

Puzzle: :~Puzzle()

{
—rdelete AttemptStack;

for(int i = 0 < Height+2;i++)
‘ ele lpia lil;
“gaele e[bpia, Ma jor memory leak. Yeu only oleleved single items instead of

whole arrays of itens.

Gonna Rese ators (ostream & Out, const Puzzle & Rhs)>

for(int i = 1;i<Rhs.Height+1;1i++)

 

 

{
for(int j = 1;3<Rhs.Width+1; j++)
{ d
Out <<Rhs.Grid[i] [j].Letter << ' '; st
}
Out << endl; ~
}
return Out;
}
obi AE
gid Puzzle: :Reset (D
{ (

for(int i = 0;i<Height+2;i++) .

;
( sorlint 4 = 0/4 < widene2+3 yah

for(int j = 0O;3 < Width+2;3+4++) Zo
f

 

PUZZLE.CPP November 13, 1997 Page 2

if(i=-0 || i == Height +1 {| G azo) |i fee Width+ 1)
Grid[i] [j].Letter = WALL; AN
else “ /

f--

 

eitse~ ;

Grid[i] [j] .Letter
Grid[i] [j] .Copies

ROW
o
~
tg
|
K
Se
Ra

 

 

int¢Puzzle::InsertOneWord(const Attempt & OneWordp

int Row = OneWord.FirstVert ();

int Golumn = OneWord.FirstHorz ();
int Birection = OneWord.Direction();
int whrdiIndex = OneWord.ID({);

I

for (int Ltr = O;ltr < Words [wordIndex] . Length () pbtr++)

K—{

Kae (Grid [Row] [@olumn] .Letter == EMPTY || Grid[Row] [Golumn] .Letter==
Words [WordIndex] [Ltr] ) f

k-( ao ef

[  ’@-Row = Bow + Directions [Birection] .vert; j

[pf Eelam = €olumn + Directions [Pirection] .Horz;

}
€— else
{, «—return 0; //failure to place word

<—
ye Row = OneWord.FirstVert ();
<— Solum = OneWord.FirstHorz () ;

-Bivection-=-OneWord: Direction) ~~, gaue value as “WOVE ~ ACAD apet
dnbndindex.=--QneWword:ID. 4}; "2
K—— for(int Ltr=0;Ltr < words [WerdIndex] .Length() ;btr++) f
<—— {
{ ——Grid [Row] [Golumn] .Letter = Words [WordIndex] [her]; a
i Grid [Row] [Golumn] .Copies++;
{ Row = Row + Directions [@irection] .Vert;
,  —— Golumn = Golumn + Directions [Rirection] .Horz;
<a |
\<—"return 1; //success

vgid @uzzle::RemoveOneWord (const Attempt & OnewWordD

int Row = OneWord.FirstVert ();

int Golumn = OneWord.PirstHorz(); -

int @irection = OneWord.Direction();

int WordIndex = OneWord.ID(); ’ (
for(int tr =0;Ltr < Words [wordIndex] .Length() ; bLtr++) i

{ , got

if (Grid [Row] [Golumn] .Copies > 1)

 

PUZZLE .CPP November 13, 1997 Page 3

Grid [flow] [Golumn] .Copies--;

else
{
Grid [Ikow] [€olumn] .Copies = 0; {
Grid [Row] [Golumn] .Letter = EMPTY;
} fo
@ehow = Bow + Directions [Birection] .Vert; g 0K
€Golum = Golum + Directions [Birection] .Horz;
}
}
Uf nnn nse

veidduzzle: :FillRemainder th

for

{

int
int
Att
whi

{

{
|

|
I
i
|
|
|
|
i
i
|
|
t
}

(int i = 1;i < Height+1;i++)
for(int j = 1;} < Width+1;j++)

{ ,
i£( Grid[i] [j] .Letter == EMPTY) gt
Grid[i] [j].Letter =char( RandGen.UniformLong('A','Z')); FF &

Tries;

Wordndx=0;

empt LocalAttempt (Wordndx,Height, Width) ;
le(LocalAttempt.ID() < Words.Length())

a

if (InsertOneWord (LocalAttempt) )

{

AttemptStack->Push (LocalAttempt) ;
LocalAttempt .NextWord () ;

+e Tres usas left uncletineR if Ne xdTe 9 veduruee® trve,

if (LocalAttempt .Ne ry()) .
x Teies- T RYE | Tries = Locel Attenpd. Next Try Oy

}

e

{

'

{

|

{ else Tries = FALSID
j while (Tries==FALSE && AttemptStack->IsEmpty () ==0)
|

{

|

t

}

{

|

i

{

{| LocalAttempt=AttemptStack->Top () ;

{ AttemptStack->Pop() ;

{ RemoveOneWord (LocalAttempt) ; 4
} Le (Localattempt .NextTry () } ries = Local Attaapt. Alea lh? ty ‘)°
' Tries = TRUE;

‘ei
k—if (Tries==FALSE)
return 0;
<—}
KK:
(—~FillRemainder () ;

return 1; {

 

ATTEMPT .CPP November 13, 1997 Page 1

//Programmer: James Moore
//Course: CS14

//File name:attempt.cpp /
//Project Name: Wordsrch

#include"attempt .h"

d#ineLude!Rndm-ht «. & rey ht ian 8 7 * attain pt. a”

[[a-~-n nnn nnn tenner

Rndm Attempt: :RandGen; 4 aok

/ [ann nn eee nnn rrr rrr Woe eee ne ee ee ee
Attempt: :Attempt (int TheWordIndex, int TheHeight,int TheWidth)

{
Height = TheHeight;
Width = TheWidth; {
Wordindex = TheWordIndex; ise
NumPositions = Width * Height; J
PickFirstTry(); //to Complete initialization

void

Attempt: :PickFirstTry ()
DirectionIndex = RandGen.UniformLong (0,NUM_DIRECTIONS-1) ;
HorzStart = RandGen.UniformLong(1,Width) ; week
VertStart RandGen.UniformLong (1,Height) ; aS

Kt

DirectionAttempt = PositionAttempt = 1;

int
Attempt: :NextTry () . Tied anf pe Fire Pde -
if (NumPositions gfPositionattempt)

e-{

‘ PositionAttempt++;

‘ HorzStart++;

‘ if (HorzStart > Width)

t HorzStart=1;

4
‘
'
t
a

q ¢ Oud, ure
if ( HorzStart==1) This prevented yo fram. mover te st res MO be
1 vertStart+t+; a Aave started in the last row ws ’ < ein, location
i '@—if( VertStart SY Height) otherwise the last vow was newer & “Y
‘ a @e-VertStart = 1;

' return 1;

<}
else if (DirectionAttempt < NUM_DIRECTIONS)
ig—{

' DirectionAttempt++;
PositionAttempt = 1;
DirectioniIndex++;

if (DirectionIndex == NUM_DIRECTIONS)
DirectionIndex = 0; {
return 1;

}

return 0;

x” a a

 

ATTEMPT .CPP November 13, 1997 Page 2

ee

a

 

a

 

Lj

 

LL mn a a I
// Programmer: Lee Greenbank
/f COWESRI sie CS 14 i)
‘/ File Name: ~~ Attempt.h :

’ project Name: Wordsrch

// Class Attempt

// Used to record one attempt to place a word within a two-dimensional puzzle
// qvid. Keeps track of current attempt, plus records all previous attempts.

// Default copy constructor and operator= with shallow copy are allowed and

// appropriate.

LL BEE RRA LAA RAIA RAR AAR THR PUBLIC OPERATIONS EKEHEAEAAERARRAAERERERARAEARE EH |
// CONSTRUCTORS}

ff Attempted

// Precondition: none

ff Ppostcondition: default constructor, does nothing. Must be followed by

// initialization with operator=() assignment.

// Attempt (int Thewordtndex, int TheHeight, int Thewidth)

// Precondition: TheWordIndex >= 0; TheHeight > 0; TheWidth > 0.

if Posteondition: The construction parameters have been stored, the munber of

if positions possible for an attempt has been computed and stored, and a
Cf first position and direction has been randomly generated.
“fe

// MEMBER FUNCTIONS:

f/f ant ID() const

// Posteondition: returns the index of the word associated with this attempt.

f/f int Firstvert() const

// postcondition: returns the vertical start position for a word insertion

Sf attempt. Range 1..Height.

// int FirstHorz() const

‘/ Postcondition: returns the horizontal start position for a word insertion
f attempt. Range 1..Width.

// aint Direction() const page i

// Postcondition: returns the direction index for a word insertion attempt.

‘/ Range 0..(NUM_DIRECTIONS-1) 4)

// void NextWord() .

//  Postcondition: Adjusts the attempt object to represent the next word in

Af the liet of words to be inserted in the word puzzle. Increments the
// word index and picks a starting attempt direction and location. Resets
S/ direction and position attempt counts.

f/f int Nextrry()
ff Precondition: none.
‘? postcondition: the appropriate HorzStart, VertStart, and/or Direct ionIndex

fe

f/f have been updated to select a previously untried position or direction
Af for the next attempt. Positionattempt and DirectionAttempt have been
“sf updated. Returns 1 if a new attempt is possible, else returns 0.

Lf RE Ae Tee Be RT Se Oe ee ee ee He ae PRIVATE OPERATIONS gh of ae ake ake okt ke ok ake ae ake ole it a ob ake abe ale oft ae oe ob ie ab ok
f/f void PickPirstfry()

// Precondition: The Width and Height have been previously set.

// Pesteondition: A random first direction index has been generated in the

ff range 0.. (NUM _DIRECTIONS-1), Direction and Position attempt counts have
‘/ been set to I, a random horizontal starting position has been generated
Sf in the range 1..Width, and a random vertical starting position has been
// generated in the range 1..Height.

Sf ee eee wee rece ce nr nn eg een et cmt vet nh A eH A i tn tA a rm wma ce

#ifndef — Attempt
#define _ Attempt

@include "Rndm.h"

const NUM _DIRECTIONS = 8; // Possible direction indexes 0..(NUM_DIRECTIONS~1)

“glass Attempt -
{

public:
Atiempt() (3); (/ Default, does no initialization, but required.

 

  

 

ink ID(} const {x
int Piretvert

  

private ;
int Wordindsxs
int DirectionIndex;

int DirectionAttempt;

int Height;

int Width;

int VertStart:

int HorzStart:

int NumPositions;
int PositionAttempt;
static Rndm RandGen;

void PickFirstTry();
hi

#endif

Neen?

Bl
fines
vatuen WordiIndex?}
const
eee {return HorzStarti
6 tiet fcbiaen Dire water ae
(wordtndext+;

Attempt (iat PheWordindex, int TheHeight, int TheWidth);// Primary meané

    

iveiurn VertStartit

 

PickFirattry ( (}?

ff Index of word represented by this objects >= 0
// 0.. (NUM DIRECTIONS ~ 1); current index UJ

Sf 1..NUM_DIRECTIONS; number of directions tried

Af Height of puzzle

// Width of puzzle

// 1..Heignht

// 1..Width

// Width * Height

// 1..NumPositions; number of positions tried

// A pseudo-random number generator Shared by class

fo jv ole

 

(

!
\

PUZZLE.H October 20, 1997 Page

fo - ee nes tes am nn cans Hee Mee caren SE ASmme a cree EE in Nm: Sct Sete pee ESE et nm mim me Tm Some met gene ee mee mee

// Programmer: Lee Greenbank

‘/ Course: CS 14

// File Name: Puzzle.h

// Project Name: WordSrch

| [nanan nanan renner nnn nnn nn ne

fi finn nn nn nn nn nn en nn erence eee

// Glass Puzzle

Af This class is used to design "Word Search" puzzles.
Me te eh ae ok oh te ie te hk Tekh kk ek ke ka PUBLIC OPERATIONS keke kha kkk ec keke keaekebekreaeee

ee

// CONSTRUCTOR:
// Puzzle(const Vector<String> & TheWords, int TheHeight, int TheWidth)

7 Precondition: TheWords is a valid reference to a constructed Vector of

ff String objects, TheHeight > 0, TheWidth > 0.

//  Postcondition: The puzzle is ready to begin word insertion. An empty
ff attempt stack has been allocated, a two-dimensional grid has been
ff allocated of size (Heightt2) by (Width+2), and the grid has been
Sf initialized to an empty state.

ff

// DESTRUCTOR:
// ~Fuzzle()

FMP este |
fF Pracondition: none.

sf Postcondition: the dynamically allocated attempt stack and puzzle grid
Af have been completely released.

Af

// MEMBER FUNCTIONS:

// int Design ()

// Precondition: The puzzle has been newly constructed and is empty.
aA Postcondition: Returns 1 if every word in the associated word list has

Sf been inserted in the puzzle grid. Unused grid locations are filled
th

‘/f randomly generated letters. Returns 0 if an exhaustive search was

ff unable to place all the words into the puzzle grid.

Sf

// FRIENDS:

/f_ostream & operator<< (ostream & Out, const Puzzle & Rhs)

Sf Precondition: Out is a constructed and open ostream, Rhs is a constr
ted
Af Puzzle.
fs Postcondition: The antire contents of the Puzzle qrid have been prin
ep a ae we ee ce pe ee ee Ge wee
ad
“ to Out from (1..Height) by (1..Width). Rows are single spaced, col
U of one letter each are separated horizontally by a single space. I
Sf entire puzzle grid is left aligned (no preceeding spaces).

Lf BRR HER HR RR RRR ARR AR RR RH PRIVATE OPERATIONS RRA aaa
we

 

Page

// MEMBER FUNCTIONS:
// woid Reset ()

 

‘4 Precondition: none.
// ~~ Postcondition: The grid has been completely set Empty except for an
fA outermost boundry of Wail.
f/f int InsertOneWord(const Attempt & OneWord)
{f/f Precondition: OneWord references a valid Attempt record with
// 0 <= OneWord.ID() < Words. Length (}".
//  Postcondition: Returns 1 if able to insert the word indexed by
Af OneWord.FD() into the puzzle grid in the direction and starting pos
ion
Sf indicated by the attempt record. Else it returns 0 and the grid is
Af deft unchanged. If the word is inserted, the copy count of each let
Lr
Sf position in the grid occupied by the word is incremented, and the
Lf detter value set.

__/¢ void RemoveOneWord (const Attempt & OneWord)

Sf Precondition: The word represented in the attempt record is currently
Sf inserted in the puzzle grid.
Lf Postcondition: The word represented by the attempt record has been re
ved
Af from the puzzle grid, its presence erased. The copy count of each J]
ter

4 position in the grid occupied by the word has been decremented, and
cf if that updated count is zero, the letter at that Position has been
at
Af krapty.

f/f void FillRemainder ()
= i= ES ny, |

{

// Precondition: none.

Af Postcondition: Every position which was still Empty in the puzzle grid
Sf has been filled with a capital letter generated at random from the
Sf range A...

Bf ann nw nn eee
#ifndef — Puzzle

#define Puzzle

#include <iostream.h>

#include "Vector.h"

#include "String.h"

#include "StackAr.h"

#include "Attempt.h"

‘lass Puzzle

t

public:

Puzzle (const Vector<String> & TheWords, int TheHeight =

20,

int TheWidth = 32);

 

bo
oO
Oo
~J
'g

a)
Ne

~Puzzle ();

int Design ():;

friend ostream & operator<< (ostream & Out, const Puzzle & Rhs);
Private :

const Vector<String> & Words; // List of words to put in puzzle

Stack<Attempt> *AttemptStack; // Stack of previously inserted words

enum {WALL = '#', EMPTY = ' '};
struct LetterBox
{
ghar Letter; /f/ A..4;7 WALL; EMPTY
int Copies; // Number of words that share the Letter
};
int Height; // Height of puzzle
int Width; // Width of puzzle
LetterBox **Grid; // Two dimensional array [Height + 2] [Width
2]
struct Offsets // Direction offsets
{
aint Vert; ff -1..1
int Horz; // ~-i1..1

};
static const Offsets Directions [NUM_DIRECTIONS ]; // Eight directions
static Rndm RandGen;

void Reset ();

int InsertOneWord (const Attempt « OneWord);
void RemoveOneWord (const Attempt & OneWord);
void FillRemainder ();:

he

teandif

 

Wordlist.h

ee
// Programmer : Lee Greenbank

// Course: cs 14

// File Name: WordList.h

// Project Name: WordSrch

| [~~~ = ~~~ == een eee nee ee

| [~~~ === == nnn nnn

// A bo¥rdeda¥ecWordifisstrings with sorting and
// trhkéepttatpnhl cabgbitdmyVector<>
: REKKEKKKEKKKEKEKEKEKEDIBLIC OPERATIONS # FREER KEE RKEKKEKKEEKEKRERKEKEKKEKEKEKEE

// CONSFRBCTOR:
// WordList (int Size, const char Name[], int TheWidth)
// Precondtion: Size >= 0; Name is a null terminated array of ch
ar;
// TheWidth > 0 (used to determine allowable printing width).
// Postcondition: the inherited Vector<String> has been construc
ted with an

// initial length of Size, the Title has been copied from Name
, and
// TheWidth stored.
// WordList (const WordList & Rhs) -- copy constructor disabled.
//
// DESTRUCTOR: inherited. (see base class for documentation)
//
// INHERITED MEMBER FUNCTIONS: (see base class for documentation)
// = --> Copy if sizes are identical
- inherited
// ] --> Indexing with bounds check
- inherited
// int Length( ) --> Return # elements in Vector
- inherited
// void Resize( int NewSize ) --> Change bounds
- inherited
// void Double( ) --> Double Vector capacity
- inherited
//
// NEW MEMBER FUNCTIONS:
// void SortByAlpha( ) --> Sort list from A..Z

// Precondition: None
// Postcondition: Entire Array from 0..(ArraySize-1) has been so

rted
// alphabetically in ascending order (A..Z).

Page 1

 

te,

Wordlist.h

// void SortBySize( ) --> Sort from largest word to smalle
st

// Precondition: None

// Postcondition: Entire Array from 0..(ArraySize-1) has been so
rted in order

// from longest String to shortest String.
//
// FRIENDS:

// friend ostream & operator<< (ostream & Out, const WordList & Rh
s)

// Precondition: Out has been constructed and opened. Rhs has be
en

// constructed.

// Postcondition: Prints entire Array of words to Out. Will prin

t in as many

// columns as will evenly fit into the given Width, allowing f
or each

// column to be large enough to hold the longest word in the A
rray, and

// for each word to be preceded by its number in the array.

| [~~~ ~~ =~ === 2 nee

#ifndef WordList
#define WordList

#include "Vector.h"
#include "String.h"

class WordList: public Vector<String>
{
public:
WordList (int Size, const char Name[{], int TheWidth) :
Vector<String> (Size), Title(Name), Width(TheWidth) {}

void SortByAlpha() ;
void SortBySize();
friend ostream & operator<< (ostream & Out, const WordList &

Rhs) ;
private:
String Title; // Title for entire list of words
int Width; // Width of area available for printin
g list

Page 2

 

Wordlist.h

// Disable copy constructor
WordList (const WordList & Rhs);

};

#endif

Page 3

 

=e

ReeTaAcmy, Nertakar Of 1QQ'7
LLL nt nds EAN Le La Nhe Le wh eh

#ifndef __AbsStack
ftdefine __AbsStack

_/f Stack abstract class interface

Sf

// Etype: must have zero-parameter constructor;

if implementation will require either

Af operator= or copy constructor, perhaps both

// CONSTRUCTION: with (a) no initializer;

/f copy construction of Stack objects is DISALLOWED

“ ee eae oe de ee oe ee oe ok ee oe A DTIBT TC OPERATIONS ¥ ¥ 8 RH RAHKAARE AA HHH HR

Lf All of the following are pure virtual functions

// void Push( Etype X ) --> Insert X

// void Pop( ) --> Remove most recently inserted item
// Etype Top( ) --> Return most recently inserted item
// int Iskmpty( ) ~-> Return 1 if empty; else return 0
// int IsFull() ~-> Return 1 if full; else return 0

// Void MakeEmpty( ) --> Remove all items

Af 2 oe ake ee ole oh he ae ee ob oe hee ee ET BO) Be oe oe oe eae ee ae ee ob oe te oe oe ae oe eee oe ob oe eo

ff

Top or Pop on empty stack

template <class Etype>
glass AbsStack

public:
AbsStack( ) { } // Default constructor
virtual ~AbsStack( ) { } // Destructor
virtual void Push( const Etype & X ) = 0; // Insert
virtual void Pop( ) = 0; // Remove
virtual const Etype & Top( ) const = 0; // Find
virtual int IsEmpty ( ) const = 0;
virtual int IsFull( ) sonst = 0;

virtual void MakeFmpty ( ) = 0;

private :
AbsStack ( const AbsStack « ) { }

l;

#tendif

 

String

#ifndef String
#define String

// String class interface: support operations for strings

// CONSTRUCTION: with (a) no initializer or (b) a

// const char * (or char *), or (c) another String

//

// KKKKKKKKKEKKKEKKKEKDPUBLIC OPERATIONS #¥ RR RR RRR KKKKKK KK ERK
// = --> Usual assignment

// --> Indexing with bounds check

// ==, !=, <, <=, >, >= -~-> Usual relational and equality
// << and >> -~> Input and output

// unsigned int Length( ) --> Return strlen equivalent

#include <iostream.h>
#include <string.h>

class String
{

public:
// Constructors
String( ).: Buffer( NullString ), BufferLen( -1 ) { }

String( const char * Value };
String( const String & Value );

// Destructor
~String( ) { if( BufferLen != -1 ) delete [ ] Buffer; }

// Assignment operator
const String & operator=( const String & Rhs );
const String & operator=( const char * Rhs );

// Extras for word search puzzle; sloppy implementation there
const String & operator=( char Rhs );
const String & operator+=( char Rhs );

char operator{ ]( int Index ) const;
char & operator[ ]( int Index );

// Type cast to char *
//operator const char * ( ) const { return Buffer; }

// Get the length
int Length( ) const { return (int)strlen( Buffer ); }

Page l

 

Poe

)e

// Friends for comparison
friend int operator ==

{ const String & Lhs,
friend int operator !=

( const String & Lhs,
friend int operator <

( const String & Lhs,
friend int operator >

( const String & Lhs,
friend int operator <=

( const String & Lhs,
friend int operator >=

( const String & Lhs,

friend ostream & operator<<( ostream & Out,

private:

}e

char *Buffer;
int BufferLen;
Static char *NullString;

String

const

const

const

const

const

const

String & Rhs );
String & Rhs );
String & Rhs );
String & Rhs );
String & Rhs });

String & Rhs );

// Stores the chars

// Max strlen for Buffer

// Member for uninitialized case
void GetBuffer( unsigned int MaxStrLen );

istream & operator>>( istream & In,

fendif

String & Value };

Page 2

const String & Value

 

oo

Stackar.h

// Stack class interface: array implementation

// Etype: must have zero-parameter constructor and operator=
// CONSTRUCTION: with (a) no initializer;

// copy construction of Stack objects is DISALLOWED

// Deep copy is supported

//

// KEKKEKKEKEKKKEEKEKEKEDUBLIC OPERATIONGE BRR KKK KRKKEKERKEREKE

// void Push( Etype X ) --> Insert X

// void Pop( ) --> Remove most recently inserted item
// Etype Top( ) --> Return most recently inserted item
// int IsEmpty( ) --> Return 1 if empty; else return 0
// int IsFull( ) --> Return 1 if full; else return 0

// void MakeEmpty( ) --> Remove all items

// HR KKRKRARK KR KKK ER EEBRROR GE RR RK EKER ER EKER EKER REE EEE

// Predefined exception is propogated if new fails
// EXCEPTION is called for Top or Pop on empty stack

#ifndef StackAr
#define _— StackAr

#include "AbsStack.h"

template <class Etype>
class Stack : public AbsStack<Etype>
{
public:
Stack( );
~Stack( ) { delete [ ] Array; }

const Stack & operator=( const Stack & Rhs );

void Push( const Etype & X );
void Pop( );

const Etype & Top( ) const;

int IsEmpty( ) const { return TopOfStack == -1; }

int IsFull( ) const { return 0; }

void MakeEmpty( ) { TopoOfStack = -1; }
private:

// Copy constructor remains disabled by inheritance

int MaxSize;
int TopOfStack;

Page 1

 

Stackar.h

Etype *Array;

};

#endif

Page 2

 

VECTOR. H October 20, 1997 Page

#ifndef Vector
#define Vector

// Vector class interface: support bounds-checked arrays

4/

// Etype: must have zero-parameter constructor and operator=
// CONSTRUCTION: with (a) an integer size only

Af
Af a Ae oe eo oe ok oe ee ee DTIRT TC OPERATIONS * #4 44H HA AEA AH

ff = --> Copy if sizes are identical |
// [ J] --> Indexing with bounds check
// int Length( ) -~-> Return # elements in Vector
// void Resize( int NewSize ) --> Change bounds

// void Double( ) --> Double Vector capacity

#include <iostream.h>
#include <stdlib.h>

template <class Etype>
Glass Vector
{
public:
// Constructors
Vector ( int Size });

// Destructor
~Vector ( ) { delete [ ] Array; }

// Index the Array
const Etype & operator[] ( int Index ) const;
Etype & operator [] ( int Index );

// Copy Identically Sized Arrays
_@onst Vector & operator=( const Vector & Rhs );

// Get. the Length
inte Length (:) const { return ArraySize; }
// Resize the Array
void Resize ( int NewSize );
void Double ( ) { Resize ( ArraySize * 2 ); }
protected: // Changed from textbook for WordSrch project (was private)
Ktype * Array;
aint ArraySize;

void GetArray( ); // Call new and check for errors

// Disable Copy constructor
Vector ( const Vector & Rhs );

 

Rndm.h

| [~~-+-------~---------------------
// Programmer: Lee Greenbank

// Course: cS 14

// File Name: Rndm.h

// Project Name: WordSrch

| [-~-----------~~------------------

ne

// This class provides functions for generating uniform, exponenti
al, Poisson,

// and normal pseudo-random distributions. In order for this to wo
rk properly,

// type long should be at least 32 bits and type double should hav
e@ a minimum

// of a 23 bit mantissa.

//

// class Rndm

// This is a class to provides a 32 bit pseudo-random number gen

erator.
[| RRRRRRKRERREREEKREKKEKEKAKEKEEKEDUBLIC OPERATIONG# REA KKK RRR RKEKEKEEEEEK

KRKKEKRKEKKKKEKEE

// CONSTRUCTOR:

// Rndm(long Sd1 = clock(), long Sd2 = time (NULL));

Jf Preconditions: none.

// Postconditions: The random number generator is constructed se
tting the

// initial seeds from Sd1 and Sd2. Seeds will be set from syst
em clock

// as default.

//

// MEMBER FUNCTIONS:

// void SetSeeds(long Sd1 = clock(), long Sd2 = time(NULL));

// Preconditions: none.

// Postconditions: Resets the internal seeds to Sd1 and Sd2. If
not

// supplied, seeds will be set from system clock.

//

// double UniformReal (void) ;

// Preconditions: none.

// Postconditions: Returns a uniformly distributed pseudorandom
real

// in the range of 0 < x < 1.

//

Page 1

 

Rndm.h

// double UniformReal (double LowerBound, double UpperBound) ;

// Preconditions: LowerBound <= UpperBound.

// Postconditions: Returns a uniformly distributed pseudorandom
real

// in the range of LowerBound < x < UpperBound

//

// long UniformLong(long LowerBound, long UpperBound) ;

// Preconditions: LowerBound <= UpperBound.

// Postconditions: Returns a uniformly distributed pseudorandom
long

// in the range of LowerBound <= x <= UpperBound.

//

// double NegExpoReal (double Mean) ;

// Preconditions: Mean > 0. Standard deviation is approximately

equal

// to the Mean.

// Postconditions: Returns a negative exponentially distributed
// pseudorandom real in the range of 0 < x < +infinity.

//

// long NegExpoLong (double Mean) ;
// Preconditions: Mean > 0. Standard deviation is approximately

equal

// to the Mean.

// Postconditions: Returns a negative exponentially distributed
// pseudorandom long in the range of 0 <= x < +infinity.

//

// double NormalReal (double Mean, double StdDev) ;

// Preconditions: StdDev > 0.

// Postconditions: Returns a normally distributed pseudorandom r
eal

// number in the range of -infinity < x < +infinity.

//

// long NormalLong(double Mean, double StdDev) ;

// Preconditions: StdDev > 0.

// Postconditions: Returns a normally distributed pseudorandom 1
ong

// in the range of -infinity < x < +infinity.

//

// unsigned int Poisson(double Mean) ;

// Preconditions: Mean > 0.

// Postconditions: This function produces an unsigned pseudorand
om Poisson

// distribution in the range of 0 <= x.

Page 2

 

ae

Rndm.h

#ifndef | Rndm
#define _Rndm

#include <Time.h>

finclude <stddef.h>

class Rndm
{
public:
// constructor
Rndm(long Sdl = clock(), long Sd2 = time(NULL));

void SetSeeds (long Sd1 = clock(), long Sd2 = time(NULL)) ;

// Uniform Distribution

double UniformReal. (void) ;

double UniformReal (double LowerBound, double UpperBound) ;
long UniformLong(long LowerBound, long UpperBound) ;

// Negative Exponential Distribution
double NegExpoReal (double Mean) ;
long NegExpoLong (double Mean) ;

// Normal Distribution
double NormalReal (double Mean, double StdDev) ;
long NormalLong (double Mean, double StdDev) ;

// Poisson Distribution
unsigned int Poisson(double Mean) ;

private:
long Seedi, Seed2;
bi

#tendif

Page 3

 

 

 
 

‘fo en wt tas see in cote wi sana tin cere ne tat he ah Bop nee a an A aa a

f/f Programmer: hee Greenbank
// Course: CS 14

th ite Name: Words rok scpp

Cee ee eee ce eee in

// This project is used to design "Word Search” puzzles. The user enters

// the file name of a list ef words which are then randomly hidden ina two

// Gimensional grid of characters. Unused positions in the grid are then

// filled with randomly generated characters to further camouflage the

// hidden words. The puzzle is displayed on screen without the word list 80

// that the results may be checked. The complete puzzle including the letter
// gvia and the word list is written to a separate text file which may then

// LOCAL FUNCTIONS:

// int main( )

// Top level entry point to program. The executive.

// Void Allcaps(char Array![]});

Sf convert all lower case letters of a string to upper case in Array[].

Sf Precondition: Array[] contains a null terminated string.
/f Postcondition: Each lower case letter in Array[] is now uppercase.
J fone en a a

#include <iostream.h>
#finclude <fstream.h>
#include “exception.h"
finclude <ctype.h>
finclude "Wordiiat.h"
#include "Puzzle.h"

( wid AllCaps(char Array[]);
/ f ee vee ap wae ee ww te me ee er ee i ene ek ne en ee A A nS he et eh um NA tw en eno ee em mr
int.
main()
{
try
{
// open log file
ofstream LogFile("Puzzles.txt", jos::trunc);
if (!LogFile)
throw "Unable to open log file!";

// Get the student's name and the date

‘cout << "Enter your First and Last Name: ";
ehar NameBuffer[50];
cin.getline(NameBuffer, 50);

LogFile << "Name : " << NameButfer << endl;

LogFile << "Project: Word Search" << endl;

time_t TheTime;

time (&TheTime);

LogFile << "Date : " <¢ dec << ctime(&TheTime) << endl;

// Do as many puzzles as the user wants
Ghar Answer?
do
{
// Get the name of the file containing the puzzle word list
( char Buffer[256]?
cout << "\nEnter the Word List filename: ";
cin >> Buffer; ,

// Open the word list input file
ifstream WordFile (Buffer);

if (WordFile)

{

// tle the firek Tinea of the File aa the nuzela brittle

 

WordFile.getline(Buffer, 256);

// Use the second line for the height and width
int Height, Width;
WordFile >> Height >> Width;

// Read and construct the word list from the remaining input fiie
WordList TheList(20, Buffer, Width * 2);

int WordCount = 0;

while (WordFile >> Buffer)

{

AllCaps (Buffer);

if (WordCount >= TheList.Length()}))

TheList.Double();

TheList [WordCount++] = Buffer;
}
TheList.Resize (WordCount); /f Shrink the list to fit
TheList.SoertBySize(); // Put longest words first

// Construct, design, and display the puzzle
Puzzle ThePuzzle(TheList, Height, Width);
1£ (ThePuzzle.Design())

{
TheList.SortByAlpha({);
cout << endl << ThePuzzle << endl;
LogFile << endl;
for (int ij = 07 i < Width * 2 - 1? i++)
LogFile << ‘'-';
LogFile << endl << ThePuzzle << endl << TheList << endl;
}
else
cerr << "Unable to create the desired puzzle.\n"
<< "Try using a bigger puzzle grid, or fewer words."
<< endl;
}
else

cerr << "Cann't open " << Buffer << endl:

// Does the user want to make another puzzle?
cout << "Do you wish to make another puzzle? (y/N): "3
cin >> Answer;

while (Answer == 'y' || Answer == 'Y¥');
tatoh (xalloc & Problem)
‘ cerr << “Error: Memory allocation exception was raised." << endl:
catch {aonst char * Msg)
‘ gers << "Error: " << Mag << endl;
catch (...)
cerr << "Error: Unidentified exception was raised." << endl;

// Flush the input buffer -- the thorough way
cin.clear();

int CharsStillInBuffer = cin.rdbuf()->in avail();
cin.ignore(CharsStillInBuffer}; ~

// Done

cout << "\nHit Enter to exit.”;

cin.ignore(200, '\n'); // Ignore everything till they hit Enter
return 0;

 

void AllCaps(char Array[])
{
for (int i = QO; Array[i]: i++)
if (islower(Array[i]})
Array[i] = char (toupper({Array[il));

 

Puzzles.txt

Name : James Moore
Project: Word Search
Date : Thu Nov 13 21:30:28 1997

c
aa

 

 

4 nse
Modes of Transportation
“1. AIRPLANE
v2. BALLOON
“3. BICYCLE
“4. BOAT
“5. CANOE
“6. CAR
“7. JET
“8. SCOOTER
“9. SHIP
10. SKATES
“41. SKIS
T2. TRAIN
“13. TRUCK
“44. VAN
(:

 

 

Page 1

 

 

Puzzles.txt

     
             
    

QLKUWST
PICCOLO

vi5.

Page 2

Musical Instruments
ENGLISHHORN

8.

vw

APPLE Y
BANANA “
BEANS “
BEET “
CARROT Y
CELERY “
ORANGE ¥
PEAR V
PEAS “
RADISH “
RUDIBAGA “
TOMATO 7

From the Garden

1.
2.
3.
4.
5.
6.
8.
9.
10.
11.
12.

  

~SnNmMHAHVARM HME wAH et VA SG
HOMME MM AOHD MOND = &
HDHPaEHEPORKEMMHEA
MA2DO4bH5eMP EMS th dw
O>KRHMOTAAM EP MHENDO
HOMOAXMKMES>MUHAOX OM HD
HH x AMDFPONZHPAZNOYE
GNOAT,HAABZH A AM NHUAN
HMHEMUOOHUMANMDNM VU EA
OCHDOHMATDHOMSNADD A
AXSDENUBHERME HMO MOH
Ze Shmapdcodtnyaprga
ANS eax ene SHOUBMHR D>
oO WR HM EMMA POM Bh
Dow? Re Ae hMOHy,H AM
AUHMAAOHMHOOHTHH ARO
HeAHE MUPEOBmMH|
AAA hAas SUNDWMUA AWA
HUNMBHaAN AAWOHRALH
PnRruLvaAaye>MNAAVARvA
bBaAAXMOPEARUONORAEH
MOSEBUAN CH eM DPAanHmM>
g€qddeoronvurta4aeanndnoge
UH ROMANE PHOHUR EOS
MOORE ODSENHAUMMHU
SNMHNBZONUOMHE HMMA
AP X KP HONANM EMO AD
CmAHHMONHNTH EMT H
HM Seta Saunt ened pao
NONdtOP>tHHOHABRMMABO
Boonr ft sortmaxpuamd
O HAOsyMUhHE

ORRMGSAVAMRYDYSAKDQOBKSBQEGERTRVDV

we

“‘UYP IYENDROIWRJUOTA

ea

NHHEBBZDIEBRULSWBZOPADICDZTBWEGOW
SDIOLXBMMHRVFBMEKWUASBHPIYZWUAUB

> OLO CCT DP

SHWBRIJIGHDJKTOMCPEATMNHYXHSSFBQUW
BASSOON

wy

 

Puzzles.txt

SAXOPHONE
TROMBONE
TRUMPET
VIOLA

“16.

FLUTE

9.
10.

CELLO

2.

“3.

17.
18.

FRENCHHORN
HARPSICHORD

OBOE

CHIMES

11.
412.

CLARINET
CORONET
CYMBALS

DRUM

4.

19.

5.

VIOLIN

20.

wal.

ORGAN
PIANO

13.

6.

7.

XYLOPHONE

14.

MAEYLQZWQBECSLRYPHOGZIMYANSVZ®O

|
j

-NNTCIMRC'A

aN
M

;
‘
i
i

ss,

Me

x

TOXAXMDAUFOPQNIHGVUEHKTWNIMKGR{
NFTPHKVSEMETNXZBYOUMSTITLANRUOJT

}

‘IIPITIKGSZCGMETWUQJAEMIAOCAESMLQAGS
OAINNAEEHIFUCZOXPMFEXRO

i
i
i

‘A
U:
ni
I

|
|
i

MIAO TAIIO

Cs
GNHUTGNHGTLBANFIGQANB

4
f

LN

 

H

a

HH
mM et 2b
Au HOA
Bag wy
Of ED
Om HH
Oona &
He PH
az Om
HH U XM
as Uw
D4 m~ WY
HDD Ee
Hs 4 >
DI> ON
Uln wm «
Hy)n Pp
mtr pl,
O}H DoH,
ULYO O
Hot oH
aOR A
nae
aH me
424uHRMN
7S Om at
HM
4

i

:

BTIIOS TNODOD

SGIUERSFCACCO.

 

“I.L LGXBFRUOMYRIC

 

YHDKPSFRENCHPCS

=
fa
mM
q
>
m4
a
Oy
Ay
oO
nn
v
p

*s,

%,

Q@®YSAUPAETGETME
SABERYHPOSOLIHPIIM

CERPNGOVERNMENT

R

3 GIYHFRSOS CMS
ELIGIOWNONEYYNWIPZOR

BR

MCMYGOLOHCYSPAQT Y

MOECONOMICS

WZ22NVYHPARGOEGHEALTHEHNUOTJRCXHU!

YDUOYMESCGEYSWSZRCCUNYSDN!

KCPHAPPKKDNLHHSMECOUSVVXESYWQSW

Departments at a University

MATHEMATICS

MINING
MUSIC

37.

“38.

FORENSICS
FORESTRY

FRENCH

19.

wi. ACCOUNTANCY

20.

AGRICULTURE

Ww.

39.

21.
22.
23.
e204,

ANTHROPOLOGY
ART

3.

NURS ING

40.

GEOGRAPHY
GEOLOGY

GERMAN

4,

PHILOSOPHY

41.

ASTRONOMY
ATHLETICS
AUDIOLOGY
BIOLOGY

5.

a

PHOTOGRAPHY
PHYSICS

42.

43.

GOVERNMENT
HEALTH

25.

v7.

PORTUGUESE

44,
45.

26.

8.

27. HISTORY PSYCHOLOGY

BUSINESS

9.

Page 3

10.
11.
12.
13.
“14,
15.
16.
Y17.

“18.

CHEMISTRY
CHINESE
COMMUNICATIONS
COMPUTERSCIENCE
DRAMA

ECONOMICS
EDUCATION
ENGINEERING
ENGLISH

28.
29.
30.
31.
32.
33.
34.
35.
36.

Puzzles.txt

HOMBECONOMICS
HUMANITIES
ITALIAN
JAPANESE
JOURNALISM
LATIN

LAW
LIBERALSTUDIES
MARKETING

Page 4

w46.
47.
48.
wd,
50.
51.
52.
53.

RELIGION
RUSSIAN
SOCIALSCIENCE
SOCIOLOGY
SPANISH
SPEECHPATHOLOGY
STATISTICS
WOMENSSTUDIES

 


